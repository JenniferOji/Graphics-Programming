<!DOCTYPE html>
<html>
<!--Import Three.js CDN-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js"></script>

<head>
    <meta charset="UTF-8">
    <title></title>
    <h1>Jennifer</h1>
    <style type="text/css">
    </style>
</head>

<body>
    <script type="text/javascript">

        //Sphere object class 
        class Sphere{
            constructor(radius,width,height,xposition,yposition,zposition,xvelocity,yvelocity,zvelocity){
                //shape of sphere
                this.radius = radius;
                this.width = width;
                this.height = height;
                //location of sphere
                this.xposition = xposition;
                this.yposition = yposition;
                this.zposition = zposition;

                //movement of sphere
                this.xvelocity = xvelocity;
                this.yvelocity = yvelocity;
                this.zvelocity = zvelocity;

                this.gravity = 0.05;           

                this.geometry = new THREE.SphereGeometry( this.radius, this.width, this.height ); 
                this.material = new THREE.MeshLambertMaterial( { color: 0xffff00, wireframe: false } ); 
               
                this.sphere = new THREE.Mesh( this.geometry, this.material ); 
                // setting the spheres position after creating it 
                //setting up the camera to cast shadow
                //to cast a shadow make sure the variants are in line
                this.sphere.castShadow = true; 
                this.sphere.receiveShadow = false; 
                scene.add( this.sphere);

            }

            // to make the sphere move 
            move(){                
                this.yvelocity-= this.gravity;
                this.yposition += this.yvelocity;

                this.xposition += this.xvelocity;
              //  this.zposition += this.zvelocity;

                //reversing the ball if it reaching the end of the canvas 
                //-20 + spheres radius(5) 
                //moving down 
                if (this.yposition <= -15){
                    this.yvelocity = this.yvelocity * -0.8;
                }
                //when the ball goes above the canvas it stops 
                //moving up
                else if (this.yposition >= 10) {
                   this.yvelocity = this.yvelocity * -1;
                }

                //the planes position for reference
                //                   x,  y,  z
                // plane.position.set(0, -20, -5);
                //plane width / heigth = 60 / 60
                //width = 30 left 30 right - radius of 5 = 25
                //when the sphere moves to the left of the canvas it stops 
                if (this.xposition <= -25){
                    this.xvelocity = this.xvelocity * -1;
                }
                //when the sphere moves to the right of the canvas it stops 
                else if (this.xposition >= 25) {
                   this.xvelocity = this.xvelocity * -1;
                }

                /*
                //when the ball bounces backward
                if (this.zposition <= -25 ) {
                  this.zvelocity = this.zvelocity * -1;
                } 
                //when the ball bounces forward 
                else if (this.zposition >= 25 ) {
                   this.zvelocity = this.zvelocity * -1;
                }
*/
                //updating the spheres position 
                this.sphere.position.set(this.xposition, this.yposition, this.zposition);

            }
        }

        // Implement scene - Create a Three.js scene to hold objects.
        var scene = new THREE.Scene();

        // Create a camera with specified properties.
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
       
        // Set camera position
        camera.position.z = 60;
       
        // Implement renderer - Create a WebGL renderer for rendering the scene.
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        //turning on shadows  
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight( 0xff0000, 1, 500);
        //                  x,  y,  z
        light.position.set( -10, 30, 60);
        light.castShadow = true; // default false
        scene.add( light );

        //Set up shadow properties for the light
        light.shadow.mapSize.width = 512; 
        light.shadow.mapSize.height = 512; 
        light.shadow.camera.near = 0.5; 
        light.shadow.camera.far = 500; 

        const geometry = new THREE.PlaneGeometry( 60, 60 );
        const material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
        const plane = new THREE.Mesh( geometry, material );
        plane.receiveShadow = true;
        scene.add( plane );
        
        const helper = new THREE.CameraHelper( light.shadow.camera );
        scene.add( helper );
        //creating sphere object 
        //            rad,wid,high,x,y,z,xvel,yvel,zvel
        s1 = new Sphere(5,32,16,  0,5,15,  0.3,0.5,0.1);

        s2 = new Sphere(5,32,16,  15,5,15,  0.3,0.5,0.1);

        //checking for a collision
        function collisionDetection(){
            // Calculate the distance between the centers of the spheres in 3D space
            var distance = Math.sqrt(
                Math.pow(s2.sphere.position.x - s1.sphere.position.x, 2) +
                Math.pow(s2.sphere.position.y - s1.sphere.position.y, 2) +
                Math.pow(s2.sphere.position.z - s1.sphere.position.z, 2)
            );

            var collisionDistance = s1.radius + s2.radius;

            if (distance <= collisionDistance){
                s1.xvelocity *= -1;
                s1.yvelocity *= -1;
                s1.zvelocity *= -1;

                s2.xvelocity *= -1;
                s2.yvelocity *= -1;
                s2.zvelocity *= -1; 
            }
        }

        //calling repeate me loop to rotate the sphere 
        function repeatMe() {
            //Code to rotate sphere
            s1.sphere.rotation.x += 0.01;
            s1.sphere.rotation.y += 0.01;
            s1.sphere.position.z = 50;

            plane.rotation.x = -Math.PI / 2;
            //                   x,  y,  z
            plane.position.set(0, -20, -5);

            s1.move();
            s2.move();

            collisionDetection();

            //having the sphere rotate on different axis 
            //s1.sphere.position.x += 0.01;
            renderer.render(scene,camera);
            window.requestAnimationFrame(repeatMe); 
        }

        repeatMe();
    </script>
</body>

</html>